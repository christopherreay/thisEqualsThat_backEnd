from persistent.mapping import PersistentMapping
from persistent.list    import PersistentList

from collections import OrderedDict as OD

import models as models

import re, logging, uuid, copy
import transaction

import ipdb

import node

#log = logging.getLogger(name)

class MyModel(PersistentMapping):
  parent = name = None
  def init(self):
    super(MyModel, self).init()
    self.parent = None
    self.name   = None
    self.id = uuid.uuid4().hex
  
  def setLocation(self, parent):
    self.parent   = parent

class User(MyModel):
  def init(self, name, parent):
    super(User, self).init()
    self.parent = parent
    self.name = name
    
    parent[self.id] = self
    
    self['id'] = self.id
    self.name = name
    self['name'] = name
    self['models'] = PersistentMapping()

class FieldUnitIndex(MyModel):
  def init(self):
    super(FieldUnitIndex, self).init()
  def addField(self, field):
    unit = field.unit
    if not unit in self:
      self[unit] = PersistentList()
    self[unit].append(field)

class OtherModel(MyModel):
  pass

class ModelClasses(MyModel):
  def init(self):
    super(ModelClasses, self).init()
  def createInstances(self, modelsByUUID, root):
    for modelClassName in self:
      modelClass = self[modelClassName]
      newInstance = modelClass.createInstance("exampleInstance", modelClass.exampleInstance)
      modelsByUUID[newInstance.id] = newInstance
      
      fieldHierarchy = newInstance.getFieldHierarchy()
      for inputFieldName in fieldHierarchy['inputFields']:
        inputField = newInstance.getFieldByFullAddress(inputFieldName)
        inputField.rootModelInstance = newInstance
        root['fieldUnitIndex'].addField(inputField)
        
class ThisEqualsThat(MyModel):
  def init():
    super(MyModel, self).init()


"""class ModelClass(MyModel):
  def init(self, name=None, parent=None):
    super(ModelClass, self).init()
    
    self.modelClassRoot = parent    
    
    self.name                   = name
    self.parent                 = parent
    self.parent[name]           = self
    
    self.fieldContext                         = PersistentMapping()
    self.fieldContext['inputFields']        = PersistentList()
    self.fieldContext['outputFields']       = PersistentList()
    
    self.fieldContext['processors']         = PersistentMapping()
    
    self.fieldContext['encapsulatedModels'] = PersistentMapping()
    self.fieldContext['encapsulatedModels']['subModels'] = PersistentMapping()
    
    self.fieldContext['defaultInputField']  = None
    self.fieldContext['defaultOutputField'] = None
    
    self.exampleInstance = PersistentMapping()
    
    self.initialiseSource     = ""
    
    self.initialiseModelClass()
    

    
    #pass
  
  def initialiseModelClass(self):
    pass

  def createInstance(self, name, user):
    newInstance = ModelInstance(name, user, self, self.modelClassRoot)
    transaction.commit()
    return newInstance
  def initialiseInstanceContext(self):
    pass

  def setLocation(self, modelInstance):
    super(MyModel, self).setLocation(modelInstance)
"""
class ModelField(MyModel):
  def setLocation(self, parentModel):#
    super(ModelField, self).setLocation(parentModel)
    self.parentModel = parentModel

class SimpleField(ModelField):
  def init(self, name, parentModel, fieldType, 
                  defaultValue, rangeBottom, rangeTop, rangeType,
                  selectableValues, 
                  unit=None, unitPrefix="", unitSuffix="",
                  inputField=False, outputField=False, 
                  defaultInputField=False, defaultOutputField=False,
                  svgComponent=None
              ):
    super(SimpleField, self).init()
    self.name                         = name
    self.name                     = name
    self.parent                   = parentModel
    self.parentModel                  = parentModel
    self.parentModel.fieldContext[name]    = self

    
    rootModelInstance                 = None
    
    self.inputField                   = inputField
    self.outputField                  = outputField
    if inputField:
      self.parentModel.fieldContext['inputFields'].append(name)
    if outputField:
      self.parentModel.fieldContext['outputFields'].append(name)

    if defaultInputField:
      self.parentModel.fieldContext["defaultInputField"]   = [name]
    if defaultOutputField:
      self.parentModel.fieldContext["defaultOutputField"]  = [name]
    
    
    self.fieldType                    = fieldType
    self.defaultValue                 = defaultValue
    
    self.rangeBottom                  = rangeBottom
    self.rangeTop                     = rangeTop
    self.rangeType                    = rangeType
    
    self.unit                         = unit
    self.unitPrefix                   = unitPrefix
    self.unitSuffix                   = unitSuffix
    
    self.selectableValues             = selectableValues
    
    self.fullAddress                  = ""
    self.currentValue                 = defaultValue
    
    transaction.commit()
  def addToModelClass(self, modelClass, name):
    pass
  def setLocation(self, parentModel):#
    super(SimpleField, self).setLocation(parentModel)
    

class CircularFieldDependencyException(Exception):
  def init(self, message):
    self.message = message
class FieldValueProcessor(ModelField):
  dependentFieldRegex       = re.compile("\!\!(?P<fieldName>.*?)\!\!")

  def init(self, name, targetFieldName, parentModel):
    super(FieldValueProcessor, self).init()
    
    self.name                       = name#
    self.name = name
    self.parent = parentModel
    
    self.targetFieldName            = targetFieldName
    self.targetField                = None
    self.currentlyProcessing        = False
    self.parentModel                = parentModel
    parentModel.fieldContext['processors'][targetFieldName] = self
    self.dependsOnInput             = False
    self.inputProcessors            = PersistentMapping()
    
    transaction.commit()

  def getTargetField(self):
    return self.parentModel.fieldContext[self.targetFieldName]
    
  def chooseEvalString(self):
    inputField = self.parentModel.currentInputField
    evalString = ""
    if inputField in self.inputProcessors:
      evalString = self.inputProcessors[inputField]
    elif "default" in self.inputProcessors:
      evalString = self.inputProcessors["default"]
    else:
      evalString = "toReturn = currentFieldValue"
    return evalString
  
  def process(self, parentModel):
    self.parentModel = parentModel
    self.targetField = self.parentModel.fieldContext[self.targetFieldName]
    
    print "processing field: %s" % self.name
    
    self.currentlyProcessing = True
    self.parentModel.currentlyProcessing[self.targetFieldName] = True
    if self.parentModel.currentInputField == self.targetFieldName:
      print "Field %s is currentInputField, returning its value %s" % (self.parentModel.currentInputField, self.targetField.currentValue)
      return self.targetField.currentValue

    evalString = self.chooseEvalString()
    dependentFields = FieldValueProcessor.dependentFieldRegex.findall(evalString)
    
    fieldProcessors = self.parentModel.fieldContext['processors']
    for dependentField in dependentFields:
      print "searching for sub-dependency: %s" % dependentField
      if dependentField in fieldProcessors:
        fieldProcessor = fieldProcessors[dependentField]
        if fieldProcessor.currentlyProcessing:
          print "Dependency %s currentlyProcessing. Dump this and return my current volume" % dependentField
          return self.targetField.currentValue

    print "DEPENDENT FIELDS"
    print dependentFields
    
    for dependentField in dependentFields:
      print "Processing %s" % dependentField
      processingField = self.parentModel.fieldContext[dependentField]
      fieldProcessors = self.parentModel.fieldContext['processors']
      fieldProcessor  = False
      if dependentField in fieldProcessors:
        fieldProcessor = fieldProcessors[dependentField]
        print "Field Processor %s" % fieldProcessor
        fieldValue = fieldProcessor.process(parentModel)
        print "Processed Value %s" % fieldValue
        evalString = \
            evalString.replace("!!%s!!" % dependentField, "%s" % fieldValue)
      else:
        fieldValue = self.parentModel.fieldContext[dependentField].currentValue
        evalString = \
            evalString.replace("!!%s!!" % dependentField, "%s" % fieldValue)
      print "replacing !!%s!! with %s" % (dependentField, fieldValue)

    currentFieldValue = self.targetField.currentValue
    toReturn = None
    print "Processing: \n%s" % (evalString, )
    exec(evalString)

    print "processedValue %s: %s" % (self.targetFieldName, toReturn)
    return toReturn
    
class EncapsulationField(ModelField):
  def init(self, name, parentModel, targetLocalField, subModelPackageName, subModelClassName, targetSubModelField):
    super(EncapsulationField, self).init()
    
    self.name                     = name
    self.targetLocalField         = targetLocalField
    self.subModelPackageName      = subModelPackageName
    self.subModelClassName        = subModelClassName
    self.targetSubModelField      = targetSubModelField
    
    self.parentModel              = parentModel
    self.getModelStorage()[targetLocalField]  = self
    self.subModel                 = None
    
    transaction.commit()
  def getModelStorage(self):
    return self.parentModel.fieldContext['encapsulatedModels']
    
  def createInstance(self, modelInstance, modelClassRoot):
    #subModelPackage = import(self.subModelPackageName, fromlist=[self.subModelClassName])
    #subModelClass   = getattr(subModelPackage, self.subModelClassName)

    #the subModelClass should really be looked up from the application registry of classes
    subModelClass = modelClassRoot[self.subModelClassName]
    newInstance = subModelClass.createInstance(self.name, self.getModelStorage()['subModels'])
    self.subModel = newInstance
    return newInstance
    
  def applyMeSubModel(self, direction):
    if direction == "input":
      self.parentModel.currentInputField  = self.targetLocalField
      self.subModel.currentOutputField    = self.targetSubModelField
    elif direction == "output":
      self.parentModel.currentOutputField = self.targetLocalField
      self.subModel.currentInputField     = self.targetSubModelField
    return self.subModel
  def applyFieldListWithDirection(self, fieldList, direction):
    if not fieldList[0] == self.targetFieldName:
      raise Exception("This is not the EncapsulationField you are looking for")
    fieldList.pop(0)
    nextSubModel = self.applyMeSubModel(direction)
    if len(fieldList) > 1:
      nextSubModelField = nextSubModel.getSubModelField(fieldList[0])
      currentList = nextSubModelField.applyFieldListWithDirection(fieldList, direction)
    else:
      if direction == "input":
        nextSubModel.currentInputField = fieldList[0]
      elif direction == "output":
        nextSubModel.currentOutputField = fieldList[0]
      currentList = [nextSubModel]
    if direction == "input":
      currentList.insert(0, self.subModel)
    elif direction == "output":
      currentList.append(self.subModel)
    return currentList


class SubModelLink(MyModel):
  def init(self):
    super(MyModel, self).init()
    parentModel            = ""
    childModel             = ""
    parentToChildEquation  = ""
    childToParentEquation  = ""

  def setParentModel(self, parentModel, localName):
    self.parentModel      = parentModel
    self.parentFieldName  = localName

  def setChildModel(self, childModel, remoteName):
    self.childModel       = childModel
    self.childFieldName   = remoteName

  def setChildToParentEquation(self, equation):
    self.childToParentEquation = equation

  def setParentToChildEquation(self, equation):
    self.parentToChildEquation = equation


  
def fieldNameIterator(dictionary):
  for fieldName in dictionary:
    if fieldName[:2] == "":
      continue
    yield fieldName
def setFieldLocations(dictionary, parent):
  for fieldName in fieldNameIterator(dictionary):
    dictionary[fieldName].setLocation(parent)
class FieldContext(object):
  def init(self):
    self.context = PersistentMapping()
  def copy(self, container):
    newFieldContext = FieldContext()
    newFieldContext.context = self.context.copy()
    setFieldLocations(newFieldContext.context, container)
  def setattr(self, key, value):
    self.context.setattr(key, value)
  def getattr(self, key):
    return self.context[key]
def copyObjectPropertiesToDictKeys(keys, obj, dictionary):
  for key in keys:
    dictionary[key] = getattr(obj, key)
def copyFieldsToNewLocation(dictionary, parent):
  for fieldName in fieldNameIterator(dictionary):
    newField = copy.copy(dictionary[fieldName])
    dictionary[fieldName] = newField
    newField.setLocation(parent)

class ModelInstance(MyModel):
  
  def init(self, name, user, modelClass, modelClassRoot):
    super(ModelInstance, self).init()

    self.parent = user
    self.name   = name

    self.modelClass     = modelClass
    self.modelClassRoot = modelClassRoot
    
    self.isTopModel           = True
    self.isBottomModel        = False
    self.bottomModel          = None
    self.boundOutputField     = False
    self.boundInputField      = False
    self.bottomModelHistory   = PersistentMapping()

    if isinstance(user, models.User):
      user['models'][name] = self
    else:
      user[name] = self
    self.fieldContext                     = modelClass.fieldContext.copy()
    self.fieldContext['modelInstance']  = self
    
    copyFieldsToNewLocation(self.fieldContext, self)
    copyFieldsToNewLocation(self.fieldContext['processors'], self)
    copyFieldsToNewLocation(self.fieldContext['encapsulatedModels'], self)
    
    self.lastAlteredInput              = self.fieldContext['defaultInputField']
    self.lastAlteredOutput             = self.fieldContext['defaultOutputField']
    
    self.currentOutputField = False
    self.currentInputField  = False
    self.currentlyProcessing            = PersistentMapping()
    
    self.buildEncapsulationTree(modelClassRoot)    
    
    transaction.commit()     
  
  def getCurrentInputField(self):
    return self.fieldContext[self.currentInputField]
  def getCurrentOutputField(self):
    return self.fieldContext[self.currentOutputField]
  
  def getSubModelFields(self):
    return self.fieldContext['encapsulatedModels']
  def getSubModelField(self, name):
    try: 
      return self.fieldContext['encapsulatedModels'][name]
    except:
      raise Exception("%s is not an address in the subModels for this Model %s" % (name, self.id))
  def getSubModel(self, name):  
    return self.fieldContext['encapsulatedModels'][name].subModel
  def getSubModelsByName(self):
    for subModelName in fieldNameIterator(self.getSubModelFields()):
      yield (subModelName, self.getSubModel(subModelName))
  
  def getFieldByFullAddress(self, fieldAddress):
    if len(fieldAddress) == 1:
      return self.fieldContext[fieldAddress[0]]
    else:
      return self.getSubModel(fieldAddress[0]).getFieldByFullAddress(fieldAddress[1:])
  def buildEncapsulationTree(self, modelClassRoot):
    encapsulatedModels = self.fieldContext['encapsulatedModels']
    for encFieldName in fieldNameIterator(encapsulatedModels):
      encField      = encapsulatedModels[encFieldName]
      encField.createInstance(self, modelClassRoot)
  
  fieldMapList = \
      [ "fieldType",
        "inputField", "outputField",
        "rangeBottom", "rangeTop", "rangeType",
        "selectableValues",
        "unit", "unitPrefix", "unitSuffix",
        "currentValue", "fullAddress"
      ]
  def getFieldHierarchy(self, address=[]):
    fieldHierarchy = OD([("id", self.id), ("name", self.name), ("inputFields",[]), ("outputFields",[]), ("fieldDefinitions",OD())])

    for fieldName in fieldNameIterator(self.fieldContext):
      fieldObject = self.fieldContext[fieldName]
      fieldFullAddress = address+[fieldName] 
      fieldObject.fullAddress = fieldFullAddress
      fieldMap    = OD()
      copyObjectPropertiesToDictKeys(self.fieldMapList, fieldObject, fieldMap)
      if fieldObject.inputField:
        fieldHierarchy['inputFields'].append(fieldFullAddress)
      if fieldObject.outputField:
        fieldHierarchy['outputFields'].append(fieldFullAddress)
      fieldHierarchy[fieldName] = fieldMap
    
      
      
    subModels = self.getSubModelFields()
    children = OD()
    for (subModelName, subModel) in self.getSubModelsByName():
      childModelData = subModel.getFieldHierarchy(address + [subModelName])
      fieldHierarchy['inputFields']   += childModelData['inputFields']
      fieldHierarchy['outputFields']  += childModelData['outputFields']
      del childModelData['inputFields']
      del childModelData['outputFields']

      children[subModelName] = childModelData
    fieldHierarchy['children'] = children
    return fieldHierarchy
  
  def flattenFieldHierarchy(self):
    pass
      
  def flattenFieldHierarchy(self):
    pass
  
  def getProcessingFields(self):
    return self.fieldContext["processors"]
  def getProcessingField(self, name):
    return self.getProcessingFields()[name]
  
  def buildProcessingSequence(self, inputField, outputField):
    inputField = list(inputField)
    outputField = list(outputField)
    toReturn = None
    if inputField[0] == outputField[0]:
      fieldName = inputField[0]
      if len(outputField) > 1:
        inputField.pop(0)
        outputField.pop(0)
        toReturn = self.getSubModel(fieldName).buildProcessingSequence(inputField, outputField)
      else:
        print "Edge Case: %s" % (outputField,)
        toReturn = self.applyFieldListWithDirection(inputField, "input")
        print "  applyInputList: %s" % toReturn
        self.currentInputField  = outputField[0]
        self.currentOutputField = outputField[0]
        print "  extended: %s" % toReturn
    else:      
      inputProcessingSequence   = self.applyFieldListWithDirection(inputField,  "input")
      outputProcessingSequence  = self.applyFieldListWithDirection(outputField, "output")
      del outputProcessingSequence[0]
      print "%s, %s" % (inputProcessingSequence, outputProcessingSequence)
      inputProcessingSequence.extend(outputProcessingSequence)
      toReturn = inputProcessingSequence
    print "%s, %s, %s" % (inputField, outputField, toReturn)
    return toReturn
  
  def applyFieldListWithDirection(self, fieldList, direction):
    print "ApplyFieldList: %s, %s, %s" % (fieldList, direction, self.name)
    recursiveList =[]
    if len(fieldList) > 1:
      subModelField = self.getSubModelField(fieldList.pop(0))
      nextSubModel = subModelField.applyMeSubModel(direction)
      recursiveList = nextSubModel.applyFieldListWithDirection(fieldList, direction)
      if direction == "input":
        recursiveList.append(self)
      elif direction == "output":
        recursiveList.insert(0, self)
    else:
      if direction == "input":
        self.currentInputField  = fieldList[0]
      elif direction == "output":
        self.currentOutputField = fieldList[0]
      recursiveList = [self]
    print recursiveList
    return recursiveList
  
  def processSequence(self, inputField, outputField):
    inputField  = list(inputField)
    outputField = list(outputField)
    print "processSequence: %s, %s" % (inputField, outputField)
    processingSequence = self.buildProcessingSequence(inputField, outputField)
    while processingSequence:
      thisInstance  = processingSequence.pop(0)
      print "ProcessInstance: %s, %s" % \
          (thisInstance.currentInputField, thisInstance.currentOutputField)
      thisInstance.process()
      
      if len(processingSequence) > 0:
        nextInstance = processingSequence[0]
        nextInstance.getCurrentInputField().currentValue = thisInstance.getCurrentOutputField().currentValue
        print "nextInstance Name: %s" % (nextInstance.name)
    return thisInstance.getCurrentOutputField().currentValue
         
  def process(self):
    writableField = self.fieldContext[self.currentOutputField]
    
    if self.currentOutputField in self.getProcessingFields():
      fieldProcessor = self.getProcessingField(self.currentOutputField)
      #try:
      writableField.currentValue = fieldProcessor.process(self)
      #except:
      #  pass

    self.clearCurrentlyProcessing()
    
    transaction.commit()
    return writableField.currentValue
    
  def clearCurrentlyProcessing(self):
    for fieldName in self.currentlyProcessing:
      self.getProcessingField(fieldName).currentlyProcessing = False
    self.currentlyProcessing.clear()
   
   
   
   
   
   
   
   
   
   
    
class Coal(ModelClass):
    def initialiseModelClass(self):
      self.fieldContext['mass']     = SimpleField("mass",       self, "slider", 100, 1, 10000000000,   "log", None, inputField=True, defaultInputField=True, outputField=True, unit="kilograms", unitSuffix="kg")
      self.fieldContext['volume']   = SimpleField("volume",     self, "slider", 100, 1, 10000000000,   "log", None, inputField=True, outputField=True, unit="m3", unitSuffix="m3")
      self.fieldContext['energy']   = SimpleField("energy",     self, "slider", 100, 1, 9999999999999, "log", None, inputField=True, outputField=True, defaultOutputField=True, unit="joules", unitSuffix="J")
      
      massField = self.fieldContext['mass']
     
      massProcessor = FieldValueProcessor("mass_processor", "mass", self)
      massProcessor.inputProcessors['energy'] = \
          """toReturn = !!energy!! / 27000000
          """
      massProcessor.inputProcessors['volume'] = \
          """toReturn = !!volume!! * 0.00120048019
          """

      volumeProcessor = FieldValueProcessor("volume_processor", "volume", self)
      volumeProcessor.inputProcessors['energy'] = \
          """toReturn = (!!energy!! / 27000000) * 0.00120048019
          """
      volumeProcessor.inputProcessors['mass'] = \
          """toReturn = !!mass!! * 0.00120048019
          """
      
      energyProcessor = FieldValueProcessor("energy_processor", "energy", self)
      energyProcessor.inputProcessors['mass'] = \
          """toReturn = !!mass!! * 27000000
          """
      energyProcessor.inputProcessors['volume'] = \
          """toReturn = (!!volume!! / 0.00120048019) * 27000000
          """
    

class CoalPowerStation(ModelClass):
  def initialiseModelClass(self):
    self.fieldContext['price']      = SimpleField("price",      self, "slider", 50000000, 1, 100000000000, "log", None, inputField=True, unit="GBP", unitSuffix="GBP")
    self.fieldContext['energy']     = SimpleField("energy",     self, "slider", 500000000, 1, 10000000000, "log", None, inputField=True, outputField=True, defaultOutputField=True, unit="joules", unitSuffix="J")
    self.fieldContext['efficiency'] = SimpleField("efficiency", self, "slider", 70, 0, 100,         "linear", None, inputField=True, defaultInputField=True, unit="%", unitSuffix="%")
    self.fieldContext['inputWatts'] = SimpleField("inputWatts", self, "slider", 123987129387, 1, 10000000000, "log",    None, unit="joules", unitSuffix="J")

    energy = FieldValueProcessor("energy_processor", "energy", self)
    energy.inputProcessors['default'] = \
      """toReturn = !!inputWatts!! * (!!efficiency!! / 100.0)
      """
   
    EncapsulationField("coal", self, "inputWatts", "zodbscafold.models", "Coal", "energy")

class Kettle(ModelClass):
  def initialiseModelClass(self):
    SimpleField("price", self, "slider", 20, 1, 200, "linear", None, inputField=True, unit="GBP", unitSuffix="GBP")
    SimpleField("energy", self, "slider", 200000, 1, 999999999999, "log", None, inputField=True, outputField=True, defaultOutputField=True, unit="joules", unitSuffix="J")
    SimpleField("waterVolume", self, "slider", 1, 0.01, 2, "linear", None, inputField=True, defaultInputField=True, outputField=True, unit="m3", unitSuffix="m3")
    SimpleField("tempChange", self, "slider", 80, 30, 160, "linear", None, inputField=True, outputField=True, unit="degreesC", unitSuffix="C")
    
    energy = FieldValueProcessor("energy_processor", "energy", self)
    energy.inputProcessors['default'] = \
      """toReturn = !!waterVolume!! * !!tempChange!! * 4186.0
      """
    
    tempChange = FieldValueProcessor("tempChangeProcessor", "tempChange", self)
    tempChange.inputProcessors['default'] = \
      """toReturn = ((!!energy!! / !!waterVolume!!)) / 4186.0
      """
    
    volume     = FieldValueProcessor("volume_processor", "waterVolume", self)
    volume.inputProcessors['default'] = \
      """toReturn = ((!!energy!!) / !!tempChange!!) / 4186.0
      """
    
